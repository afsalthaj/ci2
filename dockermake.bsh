#!/bin/bash
# This bash script manages building docker images in a standardized way for the
# CI pipeline.
#
# Default behavior is build all found Dockerfiles. Images are named by their
# containing directory path from the root.
#
# Names may be specified on the command line, if so, the build and push commands
# will be executed sequentially in order.
#
# The image tags are set from either the VERSION file in the current working
# directory, or from the TAG environment variable. Blank tags are not allowed
# and will fail the build. "latest" is explicitely filtered.
#
# RELEASE_BRANCHES environment variable can be set to an array of branches
# for which `docker push` should be allowed to run. By default it is set to
# `master`
# 
# When pushing images, the script will note and write out the name of all images
# which are successfully pushed. These are written to the dotfile .pushed_images
# so they can be used to update the gh-pages branch.
# 
# Example Usage:
# ./ci/dockermake.bsh build myimage1 myimage2 --build-arg=someval


set -u

# Library import helper
function import() {
    IMPORT_PATH="${BASH_SOURCE%/*}"
    if [[ ! -d "$IMPORT_PATH" ]]; then IMPORT_PATH="$PWD"; fi
    . $IMPORT_PATH/$1
    [ $? != 0 ] && echo "$1 import error" 1>&2 && exit 1
}

import lib-ci

# Get CI system configuration
CI_Env_Adapt $(CI_Env_Get)

# Build arguments to pass to docker build
FLAGS=()
# Requested images to build from command line
IMAGE_REQUESTS=()
# Actual list of images which will be built
TOBUILD=()
# Images which were found as candidates to be built
IMAGES=()
# Pushed image path
PUSHED_IMAGES_FILE=".pushed_images"

# Check push parameters
if [ -z $RELEASE_BRANCHES ]; then
    RELEASE_BRANCHES=("master")
fi

# Get the action requested.
ACTION=$1
shift

# Extract image arguments until flags
for arg in $1; do
    if [[ "$arg" == -* ]]; then
        break
    fi
    IMAGE_REQUESTS+=("$arg")
    shift
done

# Remainder is flags
FLAGS=("$@")

# Find all the docker images, use the directory structure for their path.
while read i ; do
    IMAGES+=( "$(dirname $i)" )
done < <(find * -name Dockerfile -type f -print | sort)

# Find the images we were requested to build, or build all if none specified.
# Note: this preserves build order to command line order.
if [ ${#IMAGE_REQUESTS[@]} -gt 0 ]; then
    for j in ${IMAGE_REQUESTS[@]}; do
        if [ $(Array_Contains "$j" "${IMAGES[@]}") -eq 0 ]; then
            TOBUILD+=( "$i" )
        fi
    done
else
    TOBUILD=${IMAGES[@]}
fi

# Set tag from environment or version file.
if [ ! -z $TAG ]; then
    TAG=$TAG
else
    TAG=$(cat VERSION)
fi

if [ "$TAG" = "latest" ]; then
    echo "\"latest\" is not allowed as a tag value. Please don't try and use it." 1>&2
    exit 1
fi

do_pages() {
  DOC_BRANCH=gh-pages
  
  if [ ! -z "$DISABLE_DOCS" ]; then
    echo "Github pages document push disabled by DISABLE_DOCS" 1>&2
    return
  fi
  
  GIT_REMOTE=$(git remote -v | cut -f2 | cut -d' ' -f1 | head -n1)
  if [ -z $GIT_REMOTE ]; then
    echoerr "No git remote could be identified. Documentation build will not work."
    return
  fi

  # Don't mess up .git dir branch state in real work dir - store where we were
  # Only relevant for local testers.
  ORIG_BRANCH=$(git symbolic-ref HEAD)
  
  # Make a site directory
  mkdir _site

  export GIT_DIR=$(pwd)/.git
  export GIT_WORK_TREE=$(pwd)/_site

  git symbolic-ref HEAD refs/heads/$DOC_BRANCH || exit 1

  # Does gh-pages exist on the remote?
  if ! git show-ref refs/remotes/$GIT_REMOTE/$DOC_BRANCH; then
      # Create an empty branch.
      echoerr "Warning: $DOC_BRANCH will be created (it did not exist on the remote)"
  else
      # Track the existent branch
      echo "Checking out current $DOC_BRANCH"
      git branch $DOC_BRANCH -f $GIT_REMOTE/$DOC_BRANCH || exit 1
      
      # Read the tree into the index so the build result is auto-available
      git read-tree refs/heads/$DOC_BRANCH || exit 1
  fi

  # Update the documentation
  cat << EOF > $GIT_WORK_TREE/index.md
---
layout: page
title: Docker Image Repository Versioning
tagline: Versioning Information Page
description: Current version of last built images from this repository.
---
# Published Images
This is the current listing of images published by this repository.
This data is also available under `version.json` for programmatic consumption.
EOF
  for image_path in ${PUSHED_IMAGES[@]}; do
    echo "* `$image_path`" >> $GIT_WORK_TREE/index.md
  done
  
  git add -A || exit 1
  git commit -m "CI automatic documentation ($CI_BUILD_URL)" || exit 1
  
  unset GIT_DIR
  unset GIT_WORK_TREE
}

do_build() {
    # Discover proxy environment
    if [ -z $https_proxy ]; then
        https_proxy=$http_proxy
    fi

    if [ -z $ftp_proxy ]; then
        ftp_proxy=$http_proxy
    fi

    for i in ${TOBUILD[@]}; do
        docker build ${BUILD_ARGS[@]} \
                     --build-arg=http_proxy=$http_proxy \
                     --build-arg=https_proxy=$http_proxy \
                     --build-arg=ftp_proxy=$http_proxy \
                     ${FLAGS[@]} \
                     -t ${PREFIX}${i}:${TAG} ${i}
         exit_code=$?
         if [ $exit_code != 0 ]; then
            echo "Docker image failed to build, exit status: $exit_code" 1>&2
            exit 1
         fi
    done
}

do_push() {
    # Aggregate pushed images here so we can publish what we have to gh-pages
    PUSHED_IMAGES=()

    if [ $(Is_Release) != 0 ]; then
        echo "$CI_BRANCH is not a release branch. Not pushing." 1>&2
    else
        failflag=0
        for i in ${TOBUILD[@]}; do
            docker push ${PREFIX}${i}:${TAG}
            if [ $? != 0 ]; then
              echo "Error pushing image: Code $exit ${PREFIX}${i}:${TAG}" 1>&2
              failflag=1
            else
              echo "${PREFIX}${i}:${TAG}" >> $PUSHED_IMAGES_FILE
            fi
        done

        if [ $failflag != 0 ]; then
          echo "Some images failed to push. Failing build." 1>&2
          exit 1
        fi
    fi
}

# Options!
echo "Actioning docker images:"
for i in ${TOBUILD[@]}; do
    echo " - ${PREFIX}${i}:${TAG}"
done

case $ACTION in
    push)
        do_push
        ;;
    build)
        do_build
        ;;
    *)
        echo "Must specify either build or push" 1>&2 && exit 1
        exit 1
        ;;
esac
